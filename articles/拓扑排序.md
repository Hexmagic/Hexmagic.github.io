### 拓扑排序
拓扑排序是图论中比较常见的算法，虽然带有排序两字但是它并不是传统意义上的排序算法。该算法一般用来探测图中是否有环，也可解决存在调度依赖的调度问题。

![](/assets/img/topsort.png)

例如上图任务0依赖于任务5和任务4，任务1依赖于任务4和任务3，任务2依赖于任务5，任务3依赖于任务2。那么如何安排上述的任务呢？

### 拓扑排序的思想


拓扑排序其实是一种贪心算法，每一步都选择没有前置依赖的任务进行完成。例如上图，任务5和任务4都没有前置依赖，我们可以先完成任务4或者任务5(由此可知拓扑排序的结果不一定唯一)。

我们可以把任务划分为两个集合A和B，A里的元素没有依赖的任务，B是其余任务。对于上图我们有：
```
A={5,4} ,B = {2,0,1,3}
```
我们从A中选择完成任意一个，这里我们选择5，任务5完成后我们需要进行两步操作：
1. 把完成的任务从A中剔除，例如完成任务5 那么`A={4}`
2. 检查B中是否有任务变为无依赖，并加入到A中。完成任务5后，任务2和任务0变为无依赖。那么`A={0,2,4}`。
重复以上的步骤即可完成全部任务，总体的流程如下：
0. 初识时：A={5,4},B ={2,0,1,3}
1. 完成5: A={0,2,4},B ={1,3}
2. 完成4: A={0,2} B={1,3}
3. 完成0: A={2} B={1,3}
4. 完成2: A={3} B={1}
5. 完成3: A={1} B={}
6. 完成1：A={} B={}

拓扑排序需要图中没有环，否则无法完成拓扑排序。因此可以通过对图进行拓扑排序，查看是否能够顺利解决所有任务来判断图中是否有环。想一下就能明白如果任务A依赖任务B，任务B又反过来依赖任务A，这在编程中叫做死锁。

### 拓扑排序的实现

拓扑排序需要两个数据结构，一个是入度表T：记录当前任务的依赖数，另一个是邻接矩阵M记录以当前任务为依赖的后续任务。借助T我们可以知道哪些任务的没有依赖，也就可以得到集合A。借助临界矩阵M我们可以知道完成当前任务哪些任务的依赖数减少。

实现代码：
```python
from collections import defaultdict
from copy import deepcopy

N = 6 # 任务数
tasks = [[0,5],[0,4],[1,4],[1,3],[2,5],[3,2]] # 依赖表

def topsort(tasks,N):
    T = dict((i,0) for i in range(N)) 
    M = defaultdict(list)
    for task in tasks:
        T[task[0]]+=1
        M[task[1]].append(task[0])
    A = {task for task in T if T[task]==0}  #无依赖任务
    topsort_rst = []
    while A:
        A_ =  deepcopy(A) # 因为python循环删除字典会报错
        for task in A_: # 完成任务task
            topsort_rst.append(task)            
            for son_task in M[task]:
                T[son_task]-=1 #更新依赖数
            A.remove(task) #剔除已完成任务    
            del T[task]         
        A|={task for task in T if T[task]==0}
    return topsort_rst

topsort(tasks,N)
```
