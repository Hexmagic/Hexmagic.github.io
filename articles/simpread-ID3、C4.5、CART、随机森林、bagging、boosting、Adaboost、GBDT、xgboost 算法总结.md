>  原文地址 [ID3、C4.5、CART、随机森林、bagging、boosting、Adaboost、GBDT、xgboost 算法总结](https://zhuanlan.zhihu.com/p/34534004)

- [一、决策树](#%e4%b8%80%e5%86%b3%e7%ad%96%e6%a0%91)
  - [(1)、ID3：以信息增益为准则来选择最优划分属性](#1id3%e4%bb%a5%e4%bf%a1%e6%81%af%e5%a2%9e%e7%9b%8a%e4%b8%ba%e5%87%86%e5%88%99%e6%9d%a5%e9%80%89%e6%8b%a9%e6%9c%80%e4%bc%98%e5%88%92%e5%88%86%e5%b1%9e%e6%80%a7)
  - [(2)、C4.5：基于信息增益率准则选择最优分割属性的算法](#2c45%e5%9f%ba%e4%ba%8e%e4%bf%a1%e6%81%af%e5%a2%9e%e7%9b%8a%e7%8e%87%e5%87%86%e5%88%99%e9%80%89%e6%8b%a9%e6%9c%80%e4%bc%98%e5%88%86%e5%89%b2%e5%b1%9e%e6%80%a7%e7%9a%84%e7%ae%97%e6%b3%95)
  - [(3)CART：以基尼系数为准则选择最优划分属性，可以应用于分类和回归](#3cart%e4%bb%a5%e5%9f%ba%e5%b0%bc%e7%b3%bb%e6%95%b0%e4%b8%ba%e5%87%86%e5%88%99%e9%80%89%e6%8b%a9%e6%9c%80%e4%bc%98%e5%88%92%e5%88%86%e5%b1%9e%e6%80%a7%e5%8f%af%e4%bb%a5%e5%ba%94%e7%94%a8%e4%ba%8e%e5%88%86%e7%b1%bb%e5%92%8c%e5%9b%9e%e5%bd%92)
  - [分类树和回归树](#%e5%88%86%e7%b1%bb%e6%a0%91%e5%92%8c%e5%9b%9e%e5%bd%92%e6%a0%91)
- [二、随机森林](#%e4%ba%8c%e9%9a%8f%e6%9c%ba%e6%a3%ae%e6%9e%97)
- [三 、GBDT 和 xgboost](#%e4%b8%89-gbdt-%e5%92%8c-xgboost)
- [四 、后记](#%e5%9b%9b-%e5%90%8e%e8%ae%b0)

### 一、决策树

首先，决策树是一个有监督的分类模型，其本质是选择一个能带来最大信息增益的特征值进行树的分割，直到到达结束条件或者叶子结点纯度到达一定阈值。下图是决策树的一个简单例子

![](https://pic1.zhimg.com/v2-a0af608723c15fc3d2ce3fc650cee4d4_b.jpg)![](https://pic1.zhimg.com/v2-a0af608723c15fc3d2ce3fc650cee4d4_r.jpg)

按照分割指标和分割方法，决策树的经典模型可以分为 ID3、C4.5 以及 CART

#### (1)、ID3：以信息增益为准则来选择最优划分属性

信息增益的计算要基于信息熵（度量样本集合纯度的指标）

![](https://pic2.zhimg.com/v2-e0ce667594401d2f8daf3ee6a7da9151_b.jpg)![](https://pic2.zhimg.com/80/v2-e0ce667594401d2f8daf3ee6a7da9151_hd.jpg) 

信息熵越小，数据集 X 的纯度越大,因此，假设于数据集 D 上建立决策树，数据有 K 个类别：

![](https://pic1.zhimg.com/v2-f6d10699fdbe216617836c7e8732ba58_b.jpg)![](https://pic1.zhimg.com/v2-f6d10699fdbe216617836c7e8732ba58_r.jpg)

公式（1）中：

![](https://pic2.zhimg.com/v2-181bbc695d6de40eff56d86518d84f29_b.jpg)![](https://pic2.zhimg.com/80/v2-181bbc695d6de40eff56d86518d84f29_hd.jpg)

表示第 k 类样本的数据占数据集 D 样本总数的比例

公式（2）表示的是以特征 A 作为分割的属性，得到的信息熵：

Di 表示的是以属性 A 为划分，分成 n 个分支，第 i 个分支的节点集合

因此，该公式求的是以属性 A 为划分，n 个分支的信息熵总和

公式（3）为分割后与分割前的信息熵的差值，也就是信息增益，越大越好

但是这种分割算法存在一定的**缺陷**：

假设每个记录有一个属性 “ID”，若按照 ID 来进行分割的话，由于 ID 是唯一的，因此在这一个属性上，能够取得的特征值等于样本的数目，也就是说 ID 的特征值很多。那么无论以哪个 ID 为划分，叶子结点的值只会有一个，纯度很大，得到的信息增益会很大，但这样划分出来的决策树是没意义的。由此可见，**ID3 决策树偏向于取值较多的属性进行分割，存在一定的偏好。**为减小这一影响，有学者提出 C4.5 的分类算法。

#### (2)、C4.5：基于信息增益率准则选择最优分割属性的算法

信息增益比率通过引入一个被称作分裂信息 (Split information) 的项来惩罚取值较多的属性。

![](https://pic2.zhimg.com/v2-c35719627c479737cb680c3f4d8cdf6d_b.jpg)![](https://pic2.zhimg.com/80/v2-c35719627c479737cb680c3f4d8cdf6d_hd.jpg)

上式，分子计算与 ID3 一样，分母是由属性 A 的特征值个数决定的，个数越多，IV 值越大，信息增益率越小，这样就可以避免模型偏好特征值多的属性，但是聪明的人一看就会发现，如果简单的按照这个规则来分割，模型又会偏向特征数少的特征。因此 C4.5 决策树先从候选划分属性中找出**信息增益高于平均水平**的属性，在从中选择**增益率最高**的。

对于连续值属性来说，可取值数目不再有限，因此可以采用离散化技术（如二分法）进行处理。将属性值从小到大排序，然后选择中间值作为分割点，数值比它小的点被划分到左子树，数值不小于它的点被分到又子树，计算分割的信息增益率，选择信息增益率最大的属性值进行分割。

#### (3)CART：以基尼系数为准则选择最优划分属性，可以应用于分类和回归

CART 是一棵二叉树，采用二元切分法，每次把数据切成两份，分别进入左子树、右子树。而且每个非叶子节点都有两个孩子，所以 CART 的叶子节点比非叶子多 1。相比 ID3 和 C4.5，CART 应用要多一些，既可以用于分类也可以用于回归。CART 分类时，使用基尼指数（Gini）来选择最好的数据分割的特征，gini 描述的是纯度，与信息熵的含义相似。CART 中每一次迭代都会降低 GINI 系数。

![](https://pic3.zhimg.com/v2-79214da261d75829046953ab9cb8b03a_b.jpg)![](https://pic3.zhimg.com/v2-79214da261d75829046953ab9cb8b03a_r.jpg)

Di 表示以 A 是属性值划分成 n 个分支里的数目

Gini(D) 反映了数据集 D 的纯度，值越小，纯度越高。我们在候选集合中选择使得划分后基尼指数最小的属性作为最优化分属性。

#### 分类树和回归树

提到决策树算法，很多想到的就是上面提到的 ID3、C4.5、CART 分类决策树。其实决策树分为分类树和回归树，前者用于分类，如晴天 / 阴天 / 雨天、用户性别、邮件是否是垃圾邮件，后者用于预测实数值，如明天的温度、用户的年龄等。

作为对比，先说分类树，我们知道 ID3、C4.5 分类树在每次分枝时，是穷举每一个特征属性的每一个阈值，找到使得按照 feature<= 阈值，和 feature> 阈值分成的两个分枝的熵最大的 feature 和阈值。按照该标准分枝得到两个新节点，用同样方法继续分枝直到所有人都被分入性别唯一的叶子节点，或达到预设的终止条件，若最终叶子节点中的性别不唯一，则以多数人的性别作为该叶子节点的性别。

回归树总体流程也是类似，不过在每个节点（不一定是叶子节点）都会得一个预测值，以年龄为例，该预测值等于属于这个节点的所有人年龄的平均值。分枝时穷举每一个 feature 的每个阈值找最好的分割点，但衡量最好的标准不再是最大熵，而是最小化均方差 -- 即（每个人的年龄 - 预测年龄）^2 的总和 / N，或者说是每个人的预测误差平方和 除以 N。这很好理解，被预测出错的人数越多，错的越离谱，均方差就越大，通过最小化均方差能够找到最靠谱的分枝依据。分枝直到每个叶子节点上人的年龄都唯一（这太难了）或者达到预设的终止条件（如叶子个数上限），若最终叶子节点上人的年龄不唯一，则以该节点上所有人的平均年龄做为该叶子节点的预测年龄。

### 二、随机森林

在讲随机森林之前，我们需要补充一点**组合分类器**的概念，将多个分类器的结果进行多票表决或者是取平均值，以此作为最终的结果。

**构建组合分类器的好处**：

1. 提升模型精度：整合各个模型的分类结果，得到更合理的决策边界，减少整体错误，实现更好的分类效果；

![](https://pic1.zhimg.com/v2-8fc5ff86df06a3c4d3f7d4b055642224_b.jpg)![](https://pic1.zhimg.com/v2-8fc5ff86df06a3c4d3f7d4b055642224_r.jpg)

2. 处理过大或过小的数据集：数据集较大时，可以将数据集划分成多个子集，对子集构建分类器；数据集较小时，可通过多种抽样方式（bootstrap）从原始数据集抽样产生多组不同的数据集，构建分类器。

3. 若决策边界过于复杂，则线性模型不能很好地描述真实情况。因此先对于特定区域的数据集，训练多个线性分类器，再将它们集成。

![](https://pic4.zhimg.com/v2-fdd9a957b915ec7711c68af1b365b30f_b.jpg)![](https://pic4.zhimg.com/v2-fdd9a957b915ec7711c68af1b365b30f_r.jpg)

4. 比较适合处理多源异构数据（存储方式不同（关系型、非关系型），类别不同（时序型、离散型、连续型、网络结构数据））

![](https://pic3.zhimg.com/v2-2743e0131bdb39de81f01649bc0f3b4e_b.jpg)![](https://pic3.zhimg.com/v2-2743e0131bdb39de81f01649bc0f3b4e_r.jpg)

随机森林是一个典型的多个决策树的组合分类器。主要包括两个方面：数据的随机性选取，以及待选特征的随机选取。

（1）、数据的随机选取：  
第一，从原始的数据集中采取有放回的抽样（bootstrap），构造子数据集，子数据集的数据量是和原始数据集相同的。不同子数据集的元素可以重复，同一个子数据集中的元素也可以重复。  
第二，利用子数据集来构建子决策树，将这个数据放到每个子决策树中，每个子决策树输出一个结果。最后，如果有了新的数据需要通过随机森林得到分类结果，就可以通过对子决策树的判断结果的投票，得到随机森林的输出结果了。如下图，假设随机森林中有 3 棵子决策树，2 棵子树的分类结果是 A 类，1 棵子树的分类结果是 B 类，那么随机森林的分类结果就是 A 类。

![](https://pic1.zhimg.com/v2-a1c3ce43528dbc274be8952c06d2b9b4_b.jpg)![](https://pic1.zhimg.com/v2-a1c3ce43528dbc274be8952c06d2b9b4_r.jpg)

（2）、待选特征的随机选取：  
与数据集的随机选取类似，随机森林中的子树的每一个分裂过程并未用到所有的待选特征，而是从所有的待选特征中随机选取一定的特征，之后再在随机选取的特征中选取最优的特征。这样能够使得随机森林中的决策树都能够彼此不同，提升系统的多样性，从而提升分类性能。

![组合树示例图](https://pic1.zhimg.com/v2-569009cc3ccd3e9922b77c1e4cbf4ca0_b.jpg)![](https://pic1.zhimg.com/v2-569009cc3ccd3e9922b77c1e4cbf4ca0_r.jpg) 

### 三 、GBDT 和 xgboost

GBDT 和 xgboost 之前，需要补充两个基本知识：bagging 和 boosting

1. **Bagging** 的思想比较简单，即每一次从原始数据中根据**均匀概率分布有放回的抽取和原始数据大小相同的样本集合**，样本点可能出现重复，然后对每一次产生的训练集构造一个分类器，再对分类器进行组合。

boosting 的每一次抽样的**样本分布都是不一样的**。每一次迭代，都根据上一次迭代的结果，**增加被错误分类的样本的权重**，使得模型能在之后的迭代中更加注意到难以分类的样本，这是一个**不断学习的过程，也是一个不断提升**的过程，这也就是 boosting 思想的本质所在。迭代之后，将每次迭代的基分类器进行集成。那么如何进行样本权重的调整和分类器的集成是我们需要考虑的关键问题。

![boosting 算法结构图](https://pic4.zhimg.com/v2-aca3644ddd56abe1e47c0f45601587c3_b.jpg)![](https://pic4.zhimg.com/v2-aca3644ddd56abe1e47c0f45601587c3_r.jpg)

拿著名的 **Adaboost 算法**举例：

![](https://pic4.zhimg.com/v2-42d79b3f2d50c86679f7c9bbc088d5f7_b.jpg)![](https://pic4.zhimg.com/v2-42d79b3f2d50c86679f7c9bbc088d5f7_r.jpg) 

我们有一个数据集，样本大小为 N，每一个样本对应一个原始标签起初，我们初始化样本的权重为 1/N![](https://pic2.zhimg.com/v2-3f8463843d3f88642a288666ecb94ff1_b.jpg)![](https://pic2.zhimg.com/v2-3f8463843d3f88642a288666ecb94ff1_r.jpg)

em 计算的是当前数据下，模型的分类误差率，模型的系数值是基于分类误差率的 ![](https://pic1.zhimg.com/v2-8d2590f60815d6389572d4f09ed9a658_b.jpg)![](https://pic1.zhimg.com/80/v2-8d2590f60815d6389572d4f09ed9a658_hd.jpg) 

根据模型的分类结果，更新原始数据中数据的分布，增加被错分的数据被抽中的概率，以便下一次迭代的时候能被模型重新训练
 ![](https://pic1.zhimg.com/v2-7000a239700933215671f4f66066ddd4_b.jpg)![](https://pic1.zhimg.com/v2-7000a239700933215671f4f66066ddd4_r.jpg) 

最终的分类器是各个基分类器的组合

2. **GBDT** 是以决策树（CART）为基学习器的 GB 算法，是**迭代树**，而不是分类树。Boost 是 "提升" 的意思，一般 Boosting 算法都是一个迭代的过程，每一次新的训练都是为了改进上一次的结果。有了前面 Adaboost 的铺垫，大家应该能很容易理解大体思想。

![](https://pic2.zhimg.com/v2-4713a5b63da71ef5afba3fcd3a65299d_b.jpg)![](https://pic2.zhimg.com/v2-4713a5b63da71ef5afba3fcd3a65299d_r.jpg)

GBDT 的核心就在于：**每一棵树学的是之前所有树结论和的残差**，这个残差就是一个加预测值后能得真实值的累加量。比如 A 的真实年龄是 18 岁，但第一棵树的预测年龄是 12 岁，差了 6 岁，即残差为 6 岁。那么在第二棵树里我们把 A 的年龄设为 6 岁去学习，如果第二棵树真的能把 A 分到 6 岁的叶子节点，那累加两棵树的结论就是 A 的真实年龄；如果第二棵树的结论是 5 岁，则 A 仍然存在 1 岁的残差，第三棵树里 A 的年龄就变成 1 岁，继续学习。

![](https://pic3.zhimg.com/v2-a384924b89b1bdd581cef7d75b56e226_b.jpg)![](https://pic3.zhimg.com/v2-a384924b89b1bdd581cef7d75b56e226_r.jpg)

3. **Xgboost** 相比于 GBDT 来说，更加有效应用了**数值优化，最重要是对损失函数**（预测值和真实值的误差）**变得更复杂**。目标函数依然是所有树的预测值相加等于预测值。

损失函数如下，引入了一阶导数，二阶导数。：

![](https://pic2.zhimg.com/v2-1c0706e463f78b6036b3923048ac9149_b.jpg)![](https://pic2.zhimg.com/v2-1c0706e463f78b6036b3923048ac9149_r.jpg) 

好的模型需要具备两个基本要素：一是要有好的精度（即好的拟合程度），二是模型要尽可能的简单（复杂的模型容易出现过拟合，并且更加不稳定）因此，我们构建的目标函数右边第一项是模型的误差项，第二项是正则化项（也就是模型复杂度的惩罚项）

常用的误差项有平方误差和逻辑斯蒂误差，常见的惩罚项有 l1，l2 正则，l1 正则是将模型各个元素进行求和，l2 正则是对元素求平方。

![](https://pic4.zhimg.com/v2-a9b82954ae62e9e6da256c69ba22d38b_b.jpg)![](https://pic4.zhimg.com/v2-a9b82954ae62e9e6da256c69ba22d38b_r.jpg)

每一次迭代，都在现有树的基础上，增加一棵树去拟合前面树的预测结果与真实值之间的残差 

![](https://pic1.zhimg.com/v2-f0cd240fcc70e7615dae7c2a29856bfc_b.jpg)![](https://pic1.zhimg.com/v2-f0cd240fcc70e7615dae7c2a29856bfc_r.jpg) 

目标函数如上图，最后一行画圈部分实际上就是预测值和真实值之间的残差

先对训练误差进行展开：

![](https://pic1.zhimg.com/v2-9f9f93d4a9d618d14201836d8f45a918_b.jpg)![](https://pic1.zhimg.com/v2-9f9f93d4a9d618d14201836d8f45a918_r.jpg)

xgboost 则对代价函数进行了二阶泰勒展开，同时用到了残差平方和的一阶和二阶导数

再研究目标函数中的正则项：

![](https://pic3.zhimg.com/v2-142ca609c9ff3dc2df877a00c30756ca_b.jpg)![](https://pic3.zhimg.com/v2-142ca609c9ff3dc2df877a00c30756ca_r.jpg)

树的复杂度可以用树的分支数目来衡量，树的分支我们可以用叶子结点的数量来表示

那么树的复杂度式子：右边第一项是叶子结点的数量 T，第二项是树的叶子结点权重 w 的 l2 正则化，正则化是为了防止叶子结点过多

此时，每一次迭代，相当于在原有模型中增加一棵树，目标函数中，我们用 wq（x）表示一棵树，包括了树的结构以及叶子结点的权重，w 表示权重（反映预测的概率），q 表示样本所在的索引号（反映树的结构）

将最终得到的目标函数对参数 w 求导，带回目标函数，可知目标函数值由红色方框部分决定：

![](https://pic1.zhimg.com/v2-c7ab2fcfd3196dbc0bce05d17b11d220_b.jpg)![](https://pic1.zhimg.com/v2-c7ab2fcfd3196dbc0bce05d17b11d220_r.jpg)

因此，xgboost 的迭代是以下图中 gain 式子定义的指标选择最优分割点的：

![](https://pic4.zhimg.com/v2-d0cf0063c23679e711146f861d36fc17_b.jpg)![](https://pic4.zhimg.com/v2-d0cf0063c23679e711146f861d36fc17_r.jpg)

**那么如何得到优秀的组合树呢？**

一种办法是贪心算法，遍历一个节点内的所有特征，按照公式计算出按照每一个特征分割的信息增益，找到信息增益最大的点进行树的分割。增加的新叶子惩罚项对应了树的剪枝，当 gain 小于某个阈值的时候，我们可以剪掉这个分割。但是这种办法不适用于数据量大的时候，因此，我们需要运用近似算法。

另一种方法：XGBoost 在寻找 splitpoint 的时候，不会枚举所有的特征值，而会对特征值进行聚合统计，按照**特征值的密度分布**，构造直方图计算特征值分布的面积，然后划分分布形成若干个 bucket(桶)，每个 bucket 的面积相同，将 **bucket 边界上的特征值**作为 split  
point 的候选，**遍历所有的候选分裂点**来找到最佳分裂点。

上图近似算法公式的解释：将特征 k 的特征值进行排序，计算特征值分布，rk（z）表示的是对于特征 k 而言，其特征值小于 z 的权重之和占总权重的比例，代表了这些特征值的重要程度，我们按照这个比例计算公式，将特征值分成若干个 bucket，每个 bucket 的比例相同，选取这几类特征值的边界作为划分候选点，构成候选集；选择候选集的条件是要使得相邻的两个候选分裂节点差值小于某个阈值

综合以上的解说，我们可以得到 xgboost 相比于 GBDT 的创新之处：

传统 GBDT 以 CART 作为基分类器，xgboost 还支持线性分类器，这个时候 xgboost 相当于带 L1 和 L2 正则化项的逻辑斯蒂回归（分类问题）或者线性回归（回归问题）。

* 传统 GBDT 在优化时只用到一阶导数信息，xgboost 则对代价函数进行了**二阶泰勒展开，同时用到了一阶和二阶导数**。顺便提一下，xgboost 工具支持自定义代价函数，只要函数可一阶和二阶求导。
* xgboost 在**代价函数里加入了正则项，用于控制模型的复杂度**。正则项里包含了树的叶子节点个数、每个叶子节点上输出的 score 的 L2 模的平方和。从 Bias-variance tradeoff 角度来讲，正则项降低了模型的 variance，使学习出来的模型更加简单，防止过拟合，这也是 xgboost 优于传统 GBDT 的一个特性。
* **Shrinkage（缩减），相当于学习速率（xgboost 中的 eta）**。每次迭代，增加新的模型，在前面成上一个小于 1 的系数，降低优化的速度，每次走一小步逐步逼近最优模型比每次走一大步逼近更加容易避免过拟合现象；
* 列抽样（column subsampling）。xgboost 借鉴了随机森林的做法，支持列抽样（即每次的输入特征不是全部特征），不仅能降低过拟合，还能减少计算，这也是 xgboost 异于传统 gbdt 的一个特性。
* 忽略缺失值：在寻找 splitpoint 的时候，不会对该特征为 missing 的样本进行遍历统计，只对该列特征值为 non-missing 的样本上对应的特征值进行遍历，通过这个工程技巧来减少了为稀疏离散特征寻找 splitpoint 的时间开销
* 指定缺失值的分隔方向：可以为缺失值或者指定的值指定分支的默认方向，为了保证完备性，会分别处理将 missing 该特征值的样本分配到左叶子结点和右叶子结点的两种情形，分到那个子节点带来的增益大，默认的方向就是哪个子节点，这能大大提升算法的效率。
* 并行化处理：在训练之前，预先对每个特征内部进行了排序找出候选切割点，然后保存为 block 结构，后面的迭代中重复地使用这个结构，大大减小计算量。在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行，即在不同的特征属性上采用多线程并行方式寻找最佳分割点。

### 四 、后记

“GBDT 的核心就在于：**每一棵树学的是之前所有树结论和的残差**，这个残差就是一个加预测值后能得真实值的累加量。比如 A 的真实年龄是 18 岁，但第一棵树的预测年龄是 12 岁，差了 6 岁，即残差为 6 岁。那么在第二棵树里我们把 A 的年龄设为 6 岁去学习，如果第二棵树真的能把 A 分到 6 岁的叶子节点，那累加两棵树的结论就是 A 的真实年龄；如果第二棵树的结论是 5 岁，则 A 仍然存在 1 岁的残差，第三棵树里 A 的年龄就变成 1 岁，继续学习。”——这段话讲得太好了，瞬间领悟，简单精辟！

☺️

“作为对比，先说分类树，我们知道 ID3、C4.5 分类树在每次分枝时，是穷举每一个特征属性的每一个阈值，找到使得按照 feature<= 阈值，和 feature> 阈值分成的两个分枝的熵最大的 feature 和阈值。”

我觉得这个地方应该是信息增益吧，熵是对集合分类的不确定性，越大不就是不确定性越大吗

你说的没错，熵最大应该换成信息增益最大，题主应该是手误

是的

随机森林部分的最后的例子能再解释一下吗 感觉跟图对应不上 谢谢！

"如下图，假设随机森林中有 3 棵子决策树，2 棵子树的分类结果是 A 类，1 棵子树的分类结果是 B 类，那么随机森林的分类结果就是 A 类。"

换句话说，就是随机森林本质上是组合模型，多票表决的意思
