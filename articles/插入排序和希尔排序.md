## 1. 插入排序
插入排序的工作方式像许多人排序一手扑克牌。开始时，我们的左手为空并且桌子上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较。拿在左手上的牌总是排序好的，原来这些牌是桌子上牌堆中顶部的牌 [1]  。
插入排序是指在待排序的元素中，假设前面n-1(其中n>=2)个数已经是排好顺序的，现将第n个数插到前面已经排好的序列中，然后找到合适自己的位置，使得插入第n个数的这个序列也是排好顺序的。按照此法对所有元素进行插入，直到整个序列排为有序的过程，称为插入排序。

时间复杂度 : O(n2)

空间复杂度 : O(1)

动态演示 : 
![](/assets/img/insert_sort.gif)

### 1.1 插入排序代码

```c++
void insert_sort(int arr[], int n)
{
    int i, key, j;
    for (i = 1; i < n; i++)
    {
        key = arr[i];
        j = i - 1;
        /* Move elements of arr[0..i-1], that are
        greater than key, to one position ahead
        of their current position */
        while (j >= 0 && arr[j] > key)
        {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}
```
## 2. 希尔排序
希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一

简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如`[5,4,3,2,1,0]`这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动

时间复杂度: 最好 O(n log^2n)，最坏O(n^2)

空间复杂度: O(1)

动态演示: ![](/assets/img/shell_sort.gif)

### 2.1 希尔排序例子

![](../assets/img/shell_sort_example.png)

### 2.2 希尔排序代码

```c++
void shell_sort(int arr[],int n){
   int gap =  n/2;
   while(gap>0){
       for(int i=gap;i<n;i++){
           int tmp = arr[i];
           int j=i;
            // 分组进行插入排序
           while(j>=0&&arr[j-gap]>tmp){
               arr[j]=arr[j-gap];
               j-=gap;
           }
           arr[j]=tmp;
       }
       gap = gap/2;
   }
}
```