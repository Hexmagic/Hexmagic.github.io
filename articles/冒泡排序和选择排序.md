## 1. 冒泡排序
冒泡排序是排序算法中较为简单的一种，英文称为Bubble Sort。它遍历所有的数据，每次对相邻元素进行两两比较，**如果顺序和预先规定的顺序不一致，则进行位置交换**；这样一次遍历会将最大或最小的数据上浮到顶端，之后再重复同样的操作，直到所有的数据有序。

时间复杂度：$O(n^2)$

空间复杂度: $O(1)$

动态演示: ![](/assets/img/bubble.gif)

### 1.1 冒泡代码
```c++
void bubble_sort(int arr[],int n){
    for(int i=n-1;i>=0;i--){
        for(int j=0;j<i;j++){
            if(arr[j]>arr[j+1]){
                std::swap(arr[j],arr[j+1]);
            }
        }
    }
}
```
## 2. 选择排序
首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。

再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。

重复第二步，直到所有元素均排序完毕。

时间复杂度: $O(n^2)$

空间复杂度：O(1)

动态演示:
![](/assets/img/selectionSort.gif)
### 2.1 选择排序代码
```c++
int select(int arr[],int i){
    int max = arr[0],ind=0;
    for(int j=0;j<=i;j++){
        // 获取最大/最小值位置，添加排序的后/前，和冒泡类似，不过是先找到元素，然后交换，冒泡是相邻就交换
        if(arr[j]>max){
            max = arr[j];
            ind=j;
        }
    }
    return ind;
}

void selectionSort(int arr[],int n){
    for(int i=n-1;i>=0;i--){
        int index = select(arr,i);
        std::swap(arr[i],arr[index]);
    }
}
```
## 3. 冒泡排序和选择排序比较

1. 冒泡排序是比较相邻位置的两个数，而选择排序是按顺序比较，找最大值或者最小值；

2. 冒泡排序每一轮比较后，位置不对都需要换位置，选择排序每一轮比较都只需要换一次位置
3. 选择排序一轮比较只需要换一次位置，排序不稳定（举个例子5，8，5，2，9   第一轮选择第一个元素5会和2交换，那么原序列中2个5的相对位置前后顺序就破坏了）